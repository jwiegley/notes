{-# LANGUAGE DataKinds #-}

module Protocol where

import Data.ByteString (ByteString)
import Data.Singletons

data Lang = EVM | Pact

-- | identifier for network and chain
data Chain
  = Ethereum
  | Chainweb Lang Int

type BlockHeight = Integer

type BlockHash = String

data Transaction = Transaction
  { chain :: Chain,
    method :: String,
    arguments :: [String]
  }

data Defpact = Defpact
  { firstPart :: Transaction,
    secondPart :: Transaction
  }

data SPV (t :: Transaction) where
  SPV :: Sing t -> RequestKey t -> BlockHash -> SPV t

-- | Evidence that a transaction was executed
--
--   ZKProofs are self-contained, and internalize any reference to the chain
--   on which the transaction was executed.
--
--   SPVProof must be validated against a valid history of the chain.
data Proof (t :: Transaction) where
  ZKProof :: Sing t -> ByteString -> Proof t
  SPVProof :: SPV t -> Proof t

type RequestKey (t :: Transaction) = String

-- Our concept of linear functions is purely syntactic in this module
type f ⊸ g = f -> g

{-

A cross-chain transaction is one in which chain A conceptually submits a
transaction to chain B with the context of something having provably
happened on chain A. We say "conceptually" since chain activity is purely
internal, requiring some external mediator to continue this sequence of
events from chain A to B.

For example: A valid mint transaction on chain B is based on provable
evidence of a corresponding burn transaction on chain A. Taken together,
this consistutes a "cross-chain transfer" between the two chains, composed
of two transactions, one on each chain, connected through the intermediate
fact of the burn.

In general form, a cross-chain transaction happens whenever an intermediate
party notices some event on chain A, and submits a transaction to chain B
that uses evidence of this event to validate the operation.

In specific form, there is usually a transaction executed on chain A that
generates both the context and action to be taken on chain B, where the
original submitter relays the information to chain B to "complete" the
cross-chain transaction.

Requirements:

1. Evidence on chain A must remain valid until the cross-chain transaction
   is "completed" or its TTL is reached.

2. The corresponding transaction on chain B may occur exactly once. This
   "consumes" the validity of the evidence on chain A, which may thereafter
   be safely "garbage collected" if appropriate.

3. Since both chains are "receive only", an active agent must operate
   between the chains to submit a transaction to chain B paired with the
   evidence from chain A.

   - In a cross-network situation, such as Kadena to Ethereum, this
     evidence might take the form of a ZK proof, or a validator-assured
     attestation.

   - In a Chainweb situation, such as Kadena chain to Kadena chain, this
     evidence takes the form of an SPV proof that references history now
     common to both chains.

-}

-- | Submit a transaction to the first chain, and then use evidence of its
--   occurrence to construct a transaction for the second chain.
--
--   The proof generated by the first transaction must remain valid until
--   execution of the second transaction is completed.
--
--   The second transaction is valid exactly once, in effect making it a
--   linear function of the evidence. Note that it is the responsibility of
--   the contract on the receiving chain to implement this notion of
--   linearity, for example by maintaining and referencing a log of
--   executions.
crossChainTransaction :: Defpact -> IO ()
crossChainTransaction _ = undefined

-- | Submit a transaction to the given chain, and then poll until evidence of
--   the transaction's execution is observed.
submitTransaction :: forall (t :: Transaction). Sing t -> IO (RequestKey t)
submitTransaction _ = undefined

awaitResult :: forall (t :: Transaction). RequestKey t -> IO (Proof t)
awaitResult _ = undefined

{-

So what are defpacts?

A defpact is implemented by having two identical copies of a contract on both
chains, and allowing the first half of the contract to execute on chain A, and
the second half to execute on chain B given evidence of execution of the first
half on chain A. Data may be produced by this first half that is available to
the second half.

This encodes the idea of a "continuation", "bound" over effects produced by
the first half of the defpact.

Another way to conceive of a defpact is as a state machine of exactly two
parts, where state produced by the first part is caried over in execution of
the second part. This is similar to how cooperative threading systems work,
except that rather than using the state machine representation of the function
to resume execution after a thread suspension, in this case it is "resumed" on
the second chain based on shared historical events observable by both chains.

Thus, a defpact defined as such:

  (defpact payment (payer payer-entity payee
                    payee-entity amount)
    (step-with-rollback payer-entity
      (debit payer amount)
      (credit payer amount))
    (step payee-entity
      (credit payee amount)))

Can be viewed as the following state machine, whose execution is spread across
two chains rather than the traditional separation of two separate executions
in the same environment. For this to work, enough details of the execution
environment must be communicated between the chains, which is achieved by
chain B receiving evidence through which it can observe that certain facts did
indeed occur on chain A.

  ARG: (payer, payer-entity, payee, payee-entity, amount)
  INITIAL → CREDITED-on-chain-A
  RET: proof

  ARG: (payer, payer-entity, payee, payee-entity, amount, proof)
  CREDITED-on-chain-A ⊸ INITIAL
  RET: ()

RET here of course is not a return value in the typical functional sense, but
is the output observed on chain after the transaction completes. The proof for
this result is constructed using the /spv input combined with the request key.

-}

{-

What about defpacts between Pact and Ethereum?

If we define a subset of Pact that can be compiled down to EVM, for example:

  - uninterpreted functions
  - basic argument types

# For the Pact to Ethereum direction

A Pact expression of the form '(module.function arg)' in the second phase of a
defpact is represented in EVM code as a function to be called on a module that
will be loaded in the EVM environment on the destination chain.

There must a compatibilty check made between this EVM bytecode and the
original defpact from which it was compiled, similar to how Pact-to-Pact
checks that the module is identical on both sides of the defpact execution.

Since the module author knows that a cross-network operation will occur, then
the process of installing the Pact module could involve compiling the defpact
second phases to EVM and storing a hash of that EVM bytecode along with the
Pact module. This would allow us to know that the proposed EVM bytecode on the
target chain corresponds to the defpact whose evidence is being transported.

The receiving Ethereum chain need a form of SPI-plugin which produces a value
that can be verified in Solidity rather than providing a Pact capability. This
means that SPI plugins will vary based on the execution environment they are
bound validating for:

  - SPI plugins for the Pact environment provide evidence in the form of a
    Pact capability, which externalizes the crypto requirements

  - SPI plugins for the EVM environment are much simpler because Solidity has
    no notion of capabilities. Once a defpact continuation is verified by the
    SPI plugin, this represents the "capability" to call the EVM functions
    mentioned in the continuation.

    In a way, this is like "blessing" the EVM evaluator.

# For the Ethereum to Pact direction

We could compile an interpreter for our subset of Pact into an EVM
pre-compile, so that the first part of the defpact execution on the EVM chain
in a way that is acceptable to the second phase of the defpact running on the
Pact chain.

-}
