A Profunctor: Ï† : ğ‘ª â†› ğ‘«, is a Functor: Ï† : (ğ‘«^op,ğ‘ª) â†’ ğ‘ºğ’†ğ’•.

Let's say I use this functor to map two objects, one each from ğ‘ª and ğ‘«, for
example: Ï†(ğ‘‘,ğ‘) : ğ‘ƒ(ğ‘‘â€²,ğ‘), where ğ‘ƒ denotes my object in ğ‘ºğ’†ğ’•.

ğ‘ƒ can be represented as a function, ğ‘‘â€² â†’ ğ‘.  When I map a function over the
ğ‘ component, it is covariant; but when I map over ğ‘‘â€² it is contravariant and
"flips" the arrow.

Thus, assume two morphisms: ğ‘“ : ğ‘ â†’ ğ‘ (in ğ‘«), and ğ‘” : ğ‘¥ â†’ ğ‘¦ (in ğ‘ª).

The operation for mapping the "right" component, ğ‘, is covariant:

    rmap : (ğ‘ â†’ ğ‘) â†’ ğ‘ƒ(ğ‘‘â€²,ğ‘) â†’ ğ‘ƒ(ğ‘‘â€²,ğ‘)

but the operation for mapping over the left component is contravariant, as it
maps ğ‘” from ğ‘ª into ğ‘«^op:

    lmap : (ğ‘¥ â†’ ğ‘¦) â†’ ğ‘ƒ(ğ‘¦,ğ‘) â†’ ğ‘ƒ(ğ‘¥,ğ‘) 

Said another way: If ğ‘ª and ğ‘« are both ğ‘¯ğ’‚ğ’”ğ’Œ, a Profunctor builds a new type out
of two Haskell types, say X and Y, and flips the direction of any function
applied to the Y component.
